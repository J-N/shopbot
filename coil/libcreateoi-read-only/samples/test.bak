#include <cstddef> // NULL
#include <iomanip>
#include <iostream>
#include <fstream>
#include <string>

#include <boost/archive/tmpdir.hpp>

#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>

#include <boost/serialization/base_object.hpp>
#include <boost/serialization/utility.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/assume_abstract.hpp>


class node;
class line;
class item;
class mapObject;
class mapObject
{
        friend class boost::serialization::access;
        template<class Archive>
        void serialize(Archive & ar, const unsigned int version)
        {
                ar & type;
                ar & visited;
                ar & id;
        }
        public:
        char type;
        bool visited;
        int id;
        mapObject()
        {
        }
        char whatAmI()
        {
                return type;
        }


};

class item
{
        //friend std::ostream & operator<<(std::ostream &os, const item &it);
        friend class boost::serialization::access;
        template<class Archive>
        void serialize(Archive & ar, const unsigned int version)
        {
                ar & id;
                ar & distance;
                ar & pLine;
        }
        public:
        int id;
        line* pLine;
        int distance; // distance from node 0 on its line
        item(int id, line* pLine, int distance)
        {
                this->id=id;
                this->pLine=pLine;
                this->distance=distance;
        }
};



class line: public mapObject
{
	 friend class boost::serialization::access;
	 template<class Archive>
	void serialize(Archive & ar, const unsigned int /* file_version */){
	 ar & boost::serialization::base_object<mapObject>(*this);
    	ar & node0;
                ar & node1;
                ar & distance;
               ar & items;

	}

	std::vector <item*> items;
	public:
	 node* node0;
        node* node1;
        int distance;
	line( node* node0, int id)
	{
		this->node0 = node0;
                this->id = id;
                this->visited = false;
                this->type = 'l';

	}
	bool hasItem(int item)
        {
                if(this->id == 3)
                        return true;
                else
                        return false;
                // iterate over vectors, ret true if match
        }


};



class node: public mapObject
{
	 friend class boost::serialization::access;
  	 int num;
	 template<class Archive>
	void serialize(Archive & ar, const unsigned int /* file_version */){
	 ar & boost::serialization::base_object<mapObject>(*this);
       	 ar & num;
	 ar & connections;
    	}

	public:
	line* connections[3];
	node( int d)
	{
		this->num = d;
	}
};


std::vector<node*> nodes;

void constructMap()
{
        node* homeNode = new node(0);
        nodes.push_back(homeNode);
        line* line1 = new line(homeNode,3);
        homeNode->connections[1]=line1;
        node* topNode = new node(1);
        nodes.push_back(topNode);
        topNode->connections[2]=line1;
        line1->node1=topNode;
        line1->distance = 1000;


/*        std::ofstream ofs("line1");
        boost::archive::text_oarchive oa(ofs);
        oa << *line1;
*/
        line* line2 = new line(topNode,4);
        topNode->connections[0]=line2;
        node* botNode = new node(2);
        nodes.push_back(botNode);
        botNode->connections[2]=line2;
        line2->node1=botNode;
        line2->distance = 1000;

        line* line3 = new line(botNode,5);
        botNode->connections[1]=line3;
        topNode->connections[1]=line3;
        line3->node1=topNode;
        line3->distance = 500;

        line* line4 = new line(botNode,6);
        botNode->connections[0]=line4;
        homeNode->connections[2]=line4;
        line4->node1=homeNode;
        line4->distance = 500;


}


int main()
{

	//std::vector<int> grr;

	//node* t = new node(12);
	//line* t2 = new line(t,33);
/*	
	 node* homeNode = new node(0);
	 line* line1 = new line(homeNode,3);
	homeNode->connections[1]=line1;
	node* topNode = new node(1);
//        nodes.push_back(topNode);
        topNode->connections[2]=line1;
        line1->node1=topNode;
        line1->distance = 1000;
*/

	constructMap();

	 item* myItem = new item(1337,nodes[0]->connections[1], 200);

	std::ofstream ofs("tser3");
	boost::archive::text_oarchive oa(ofs);
    	oa << nodes;

	return 1;
}

